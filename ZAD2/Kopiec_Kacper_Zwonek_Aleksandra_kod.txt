import numpy as np
from Float import Float
from enum import Enum

class Triangular(Enum):
    NONE = 1
    UPPER = 2
    LOWER = 3

def inverse(A: np.ndarray, triangular: Triangular = Triangular.NONE) -> np.ndarray:
    n = A.shape[0]

    if n == 1:
        return np.array([[1.0 / A[0, 0]]], dtype=Float)
    
    k = n // 2
    A11_inv = inverse(A[:k, :k])

    match triangular:
        case Triangular.LOWER | Triangular.UPPER:
            S22_inv = inverse(A[k:, k:])
            C11 = A11_inv
            if triangular == Triangular.LOWER:
                C12 = np.vectorize(Float)(np.zeros((k, n - k), dtype=Float))
                C21 = -S22_inv @ A[k:, :k] @ A11_inv
            elif triangular == Triangular.UPPER:
                C12 =  -A11_inv @ A[:k, k:] @  S22_inv
                C21 = np.vectorize(Float)(np.zeros((n - k, k), dtype=Float))
        case Triangular.NONE:
            S22_inv = inverse(A[k:, k:] -A[k:, :k] @ A11_inv @ A[:k, k:])
            X = A11_inv @ A[:k, k:] @ S22_inv
            Y = A[k:, :k] @ A11_inv
            C11 = A11_inv + X @ Y
            C12 = -X
            C21 = -S22_inv @ Y
    
    top = np.hstack((C11, C12), dtype=Float)
    bot = np.hstack((C21, S22_inv), dtype=Float)
    return np.vstack((top, bot), dtype=Float)


import numpy as np
from Float import Float
from inverse import *
from lu import lu_factorization
from typing import Tuple

def gauss_elimination(A: np.ndarray, b: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    n = A.shape[0]

    if n == 1:
        return np.array([[Float(1)]], dtype=Float), np.array([[b[0, 0] / A[0, 0]]], dtype=Float)
    
    k = n // 2
    L11, U11 = lu_factorization(A[:k, :k])
    L11_inv = inverse(L11, triangular=Triangular.LOWER)
    A11_inv = inverse(A[:k, :k])

    C11 = U11
    C12 = L11_inv @ A[:k, k:]
    C21 = np.vectorize(Float)(np.zeros((n - k, k), dtype=Float))
    S = A[k:, k:] - A[k:, :k] @ A11_inv @ A[:k, k:]
    LS, LU = lu_factorization(S)
    LS_inv = inverse(LS, triangular=Triangular.LOWER)
    C22 = LU

    b1 = L11_inv @ b[:k, :]
    b2 = LS_inv @ (b[k:, :] - A[k:, :k] @ A11_inv @ b[:k, :])

    Ctop = np.hstack((C11, C12), dtype=Float)
    Cbot = np.hstack((C21, C22), dtype=Float)

    C = np.vstack((Ctop, Cbot), dtype=Float)
    b_ans = np.vstack((b1, b2), dtype=Float)
    return C, b_ans

def back_substitution(A: np.ndarray, b: np.ndarray) -> np.ndarray:
    n = A.shape[0]
    x = np.zeros((n, 1), dtype=Float)
    
    for i in range(n - 1, -1, -1):
        sum_ax = Float(0)
        for j in range(i + 1, n):
            sum_ax += A[i, j] * x[j, 0]        
        x[i, 0] = (b[i, 0] - sum_ax) / A[i, i]
    return x

from Float import Float
import numpy as np
from typing import Tuple
from inverse import inverse, Triangular

def lu_factorization(A: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    n = A.shape[0]

    if n == 1:
        return np.array([[Float(1)]], dtype=Float), np.array([[A[0, 0]]], dtype=Float)
    
    k = n // 2
    L11, U11 = lu_factorization(A[:k, :k])
    L21 = A[k:, :k] @ inverse(U11, triangular=Triangular.UPPER)
    U12 = inverse(L11, triangular=Triangular.LOWER) @ A[:k, k:]
    LS, US = lu_factorization(A[k:, k:] - L21 @ U12)

    Ltop = np.hstack((L11, np.vectorize(Float)(np.zeros((k, n - k), dtype=Float))), dtype=Float)
    Lbot = np.hstack((L21, LS), dtype=Float)

    Rtop = np.hstack((U11, U12), dtype=Float)
    Rbot = np.hstack((np.vectorize(Float)(np.zeros((n - k, k), dtype=Float)), US), dtype=Float)

    return np.vstack((Ltop, Lbot), dtype=Float), np.vstack((Rtop, Rbot), dtype=Float)

def determinant(A: np.ndarray) -> Float:
    L, U = lu_factorization(A)
    n = A.shape[0]
    det = Float(1)
    
    for i in range(n):
        det *= L[i, i] * U[i, i]
    
    return det

import numpy as np
from Float import Float

def random_matrix(n: int):
    matrix = np.random.random((n, n)) + 0.00000001
    return np.frompyfunc(Float, 1, 1)(matrix)

def random_lower_triangular(n: int):
    mat = np.random.random((n, n)) + 0.00000001
    lower = np.tril(mat)
    return np.frompyfunc(Float, 1, 1)(lower)

def random_upper_triangular(n: int):
    mat = np.random.random((n, n)) + 0.00000001
    upper = np.triu(mat)
    return np.frompyfunc(Float, 1, 1)(upper)

def random_vector_T(n: int):
    matrix = np.random.random((n, 1)) + 0.00000001
    return np.frompyfunc(Float, 1, 1)(matrix)